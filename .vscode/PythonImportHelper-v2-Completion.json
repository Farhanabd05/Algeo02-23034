[
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "stringify",
        "importPath": "flatted",
        "description": "flatted",
        "isExtraImport": true,
        "detail": "flatted",
        "documentation": {}
    },
    {
        "label": "parse",
        "importPath": "flatted",
        "description": "flatted",
        "isExtraImport": true,
        "detail": "flatted",
        "documentation": {}
    },
    {
        "label": "predict_and_save",
        "importPath": "basic_pitch.inference",
        "description": "basic_pitch.inference",
        "isExtraImport": true,
        "detail": "basic_pitch.inference",
        "documentation": {}
    },
    {
        "label": "predict_and_save",
        "importPath": "basic_pitch.inference",
        "description": "basic_pitch.inference",
        "isExtraImport": true,
        "detail": "basic_pitch.inference",
        "documentation": {}
    },
    {
        "label": "predict_and_save",
        "importPath": "basic_pitch.inference",
        "description": "basic_pitch.inference",
        "isExtraImport": true,
        "detail": "basic_pitch.inference",
        "documentation": {}
    },
    {
        "label": "ICASSP_2022_MODEL_PATH",
        "importPath": "basic_pitch",
        "description": "basic_pitch",
        "isExtraImport": true,
        "detail": "basic_pitch",
        "documentation": {}
    },
    {
        "label": "ICASSP_2022_MODEL_PATH",
        "importPath": "basic_pitch",
        "description": "basic_pitch",
        "isExtraImport": true,
        "detail": "basic_pitch",
        "documentation": {}
    },
    {
        "label": "ICASSP_2022_MODEL_PATH",
        "importPath": "basic_pitch",
        "description": "basic_pitch",
        "isExtraImport": true,
        "detail": "basic_pitch",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "path",
        "importPath": "os",
        "description": "os",
        "isExtraImport": true,
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "shutil",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "shutil",
        "description": "shutil",
        "detail": "shutil",
        "documentation": {}
    },
    {
        "label": "process_audio",
        "importPath": "audioSearching",
        "description": "audioSearching",
        "isExtraImport": true,
        "detail": "audioSearching",
        "documentation": {}
    },
    {
        "label": "Features",
        "importPath": "audioSearching",
        "description": "audioSearching",
        "isExtraImport": true,
        "detail": "audioSearching",
        "documentation": {}
    },
    {
        "label": "Features",
        "importPath": "audioSearching",
        "description": "audioSearching",
        "isExtraImport": true,
        "detail": "audioSearching",
        "documentation": {}
    },
    {
        "label": "pickle",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pickle",
        "description": "pickle",
        "detail": "pickle",
        "documentation": {}
    },
    {
        "label": "codecs",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "codecs",
        "description": "codecs",
        "detail": "codecs",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "mido",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "mido",
        "description": "mido",
        "detail": "mido",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "pandas",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pandas",
        "description": "pandas",
        "detail": "pandas",
        "documentation": {}
    },
    {
        "label": "grayscaleConvert",
        "importPath": "processNewImage",
        "description": "processNewImage",
        "isExtraImport": true,
        "detail": "processNewImage",
        "documentation": {}
    },
    {
        "label": "flattenImage",
        "importPath": "processNewImage",
        "description": "processNewImage",
        "isExtraImport": true,
        "detail": "processNewImage",
        "documentation": {}
    },
    {
        "label": "argparse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "argparse",
        "description": "argparse",
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "_Known",
        "kind": 6,
        "importPath": "node_modules.flatted.python.flatted",
        "description": "node_modules.flatted.python.flatted",
        "peekOfCode": "class _Known:\n    def __init__(self):\n        self.key = []\n        self.value = []\nclass _String:\n    def __init__(self, value):\n        self.value = value\ndef _array_keys(value):\n    keys = []\n    i = 0",
        "detail": "node_modules.flatted.python.flatted",
        "documentation": {}
    },
    {
        "label": "_String",
        "kind": 6,
        "importPath": "node_modules.flatted.python.flatted",
        "description": "node_modules.flatted.python.flatted",
        "peekOfCode": "class _String:\n    def __init__(self, value):\n        self.value = value\ndef _array_keys(value):\n    keys = []\n    i = 0\n    for _ in value:\n        keys.append(i)\n        i += 1\n    return keys",
        "detail": "node_modules.flatted.python.flatted",
        "documentation": {}
    },
    {
        "label": "parse",
        "kind": 2,
        "importPath": "node_modules.flatted.python.flatted",
        "description": "node_modules.flatted.python.flatted",
        "peekOfCode": "def parse(value, *args, **kwargs):\n    json = _json.loads(value, *args, **kwargs)\n    wrapped = []\n    for value in json:\n        wrapped.append(_wrap(value))\n    input = []\n    for value in wrapped:\n        if isinstance(value, _String):\n            input.append(value.value)\n        else:",
        "detail": "node_modules.flatted.python.flatted",
        "documentation": {}
    },
    {
        "label": "stringify",
        "kind": 2,
        "importPath": "node_modules.flatted.python.flatted",
        "description": "node_modules.flatted.python.flatted",
        "peekOfCode": "def stringify(value, *args, **kwargs):\n    known = _Known()\n    input = []\n    output = []\n    i = int(_index(known, input, value))\n    while i < len(input):\n        output.append(_transform(known, input, input[i]))\n        i += 1\n    return _json.dumps(output, *args, **kwargs)",
        "detail": "node_modules.flatted.python.flatted",
        "documentation": {}
    },
    {
        "label": "stringify",
        "kind": 2,
        "importPath": "node_modules.flatted.python.test",
        "description": "node_modules.flatted.python.test",
        "peekOfCode": "def stringify(value):\n    return _stringify(value, separators=(',', ':'))\nassert stringify([None, None]) == '[[null,null]]'\na = []\no = {}\nassert stringify(a) == '[[]]'\nassert stringify(o) == '[{}]'\na.append(a)\no['o'] = o\nassert stringify(a) == '[[\"0\"]]'",
        "detail": "node_modules.flatted.python.test",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "node_modules.flatted.python.test",
        "description": "node_modules.flatted.python.test",
        "peekOfCode": "a = []\no = {}\nassert stringify(a) == '[[]]'\nassert stringify(o) == '[{}]'\na.append(a)\no['o'] = o\nassert stringify(a) == '[[\"0\"]]'\nassert stringify(o) == '[{\"o\":\"0\"}]'\nb = parse(stringify(a))\nassert isinstance(b, list) and b[0] == b",
        "detail": "node_modules.flatted.python.test",
        "documentation": {}
    },
    {
        "label": "o",
        "kind": 5,
        "importPath": "node_modules.flatted.python.test",
        "description": "node_modules.flatted.python.test",
        "peekOfCode": "o = {}\nassert stringify(a) == '[[]]'\nassert stringify(o) == '[{}]'\na.append(a)\no['o'] = o\nassert stringify(a) == '[[\"0\"]]'\nassert stringify(o) == '[{\"o\":\"0\"}]'\nb = parse(stringify(a))\nassert isinstance(b, list) and b[0] == b\na.append(1)",
        "detail": "node_modules.flatted.python.test",
        "documentation": {}
    },
    {
        "label": "o['o']",
        "kind": 5,
        "importPath": "node_modules.flatted.python.test",
        "description": "node_modules.flatted.python.test",
        "peekOfCode": "o['o'] = o\nassert stringify(a) == '[[\"0\"]]'\nassert stringify(o) == '[{\"o\":\"0\"}]'\nb = parse(stringify(a))\nassert isinstance(b, list) and b[0] == b\na.append(1)\na.append('two')\na.append(True)\no['one'] = 1\no['two'] = 'two'",
        "detail": "node_modules.flatted.python.test",
        "documentation": {}
    },
    {
        "label": "b",
        "kind": 5,
        "importPath": "node_modules.flatted.python.test",
        "description": "node_modules.flatted.python.test",
        "peekOfCode": "b = parse(stringify(a))\nassert isinstance(b, list) and b[0] == b\na.append(1)\na.append('two')\na.append(True)\no['one'] = 1\no['two'] = 'two'\no['three'] = True\nassert stringify(a) == '[[\"0\",1,\"1\",true],\"two\"]'\nassert stringify(o) == '[{\"o\":\"0\",\"one\":1,\"two\":\"1\",\"three\":true},\"two\"]'",
        "detail": "node_modules.flatted.python.test",
        "documentation": {}
    },
    {
        "label": "o['one']",
        "kind": 5,
        "importPath": "node_modules.flatted.python.test",
        "description": "node_modules.flatted.python.test",
        "peekOfCode": "o['one'] = 1\no['two'] = 'two'\no['three'] = True\nassert stringify(a) == '[[\"0\",1,\"1\",true],\"two\"]'\nassert stringify(o) == '[{\"o\":\"0\",\"one\":1,\"two\":\"1\",\"three\":true},\"two\"]'\na.append(o)\no['a'] = a\nassert stringify(a) == '[[\"0\",1,\"1\",true,\"2\"],\"two\",{\"o\":\"2\",\"one\":1,\"two\":\"1\",\"three\":true,\"a\":\"0\"}]'\nassert stringify(o) == '[{\"o\":\"0\",\"one\":1,\"two\":\"1\",\"three\":true,\"a\":\"2\"},\"two\",[\"2\",1,\"1\",true,\"0\"]]'\na.append({'test': 'OK'})",
        "detail": "node_modules.flatted.python.test",
        "documentation": {}
    },
    {
        "label": "o['two']",
        "kind": 5,
        "importPath": "node_modules.flatted.python.test",
        "description": "node_modules.flatted.python.test",
        "peekOfCode": "o['two'] = 'two'\no['three'] = True\nassert stringify(a) == '[[\"0\",1,\"1\",true],\"two\"]'\nassert stringify(o) == '[{\"o\":\"0\",\"one\":1,\"two\":\"1\",\"three\":true},\"two\"]'\na.append(o)\no['a'] = a\nassert stringify(a) == '[[\"0\",1,\"1\",true,\"2\"],\"two\",{\"o\":\"2\",\"one\":1,\"two\":\"1\",\"three\":true,\"a\":\"0\"}]'\nassert stringify(o) == '[{\"o\":\"0\",\"one\":1,\"two\":\"1\",\"three\":true,\"a\":\"2\"},\"two\",[\"2\",1,\"1\",true,\"0\"]]'\na.append({'test': 'OK'})\na.append([1, 2, 3])",
        "detail": "node_modules.flatted.python.test",
        "documentation": {}
    },
    {
        "label": "o['three']",
        "kind": 5,
        "importPath": "node_modules.flatted.python.test",
        "description": "node_modules.flatted.python.test",
        "peekOfCode": "o['three'] = True\nassert stringify(a) == '[[\"0\",1,\"1\",true],\"two\"]'\nassert stringify(o) == '[{\"o\":\"0\",\"one\":1,\"two\":\"1\",\"three\":true},\"two\"]'\na.append(o)\no['a'] = a\nassert stringify(a) == '[[\"0\",1,\"1\",true,\"2\"],\"two\",{\"o\":\"2\",\"one\":1,\"two\":\"1\",\"three\":true,\"a\":\"0\"}]'\nassert stringify(o) == '[{\"o\":\"0\",\"one\":1,\"two\":\"1\",\"three\":true,\"a\":\"2\"},\"two\",[\"2\",1,\"1\",true,\"0\"]]'\na.append({'test': 'OK'})\na.append([1, 2, 3])\no['test'] = {'test': 'OK'}",
        "detail": "node_modules.flatted.python.test",
        "documentation": {}
    },
    {
        "label": "o['a']",
        "kind": 5,
        "importPath": "node_modules.flatted.python.test",
        "description": "node_modules.flatted.python.test",
        "peekOfCode": "o['a'] = a\nassert stringify(a) == '[[\"0\",1,\"1\",true,\"2\"],\"two\",{\"o\":\"2\",\"one\":1,\"two\":\"1\",\"three\":true,\"a\":\"0\"}]'\nassert stringify(o) == '[{\"o\":\"0\",\"one\":1,\"two\":\"1\",\"three\":true,\"a\":\"2\"},\"two\",[\"2\",1,\"1\",true,\"0\"]]'\na.append({'test': 'OK'})\na.append([1, 2, 3])\no['test'] = {'test': 'OK'}\no['array'] = [1, 2, 3]\nassert stringify(a) == '[[\"0\",1,\"1\",true,\"2\",\"3\",\"4\"],\"two\",{\"o\":\"2\",\"one\":1,\"two\":\"1\",\"three\":true,\"a\":\"0\",\"test\":\"3\",\"array\":\"4\"},{\"test\":\"5\"},[1,2,3],\"OK\"]'\nassert stringify(o) == '[{\"o\":\"0\",\"one\":1,\"two\":\"1\",\"three\":true,\"a\":\"2\",\"test\":\"3\",\"array\":\"4\"},\"two\",[\"2\",1,\"1\",true,\"0\",\"3\",\"4\"],{\"test\":\"5\"},[1,2,3],\"OK\"]'\na2 = parse(stringify(a));",
        "detail": "node_modules.flatted.python.test",
        "documentation": {}
    },
    {
        "label": "o['test']",
        "kind": 5,
        "importPath": "node_modules.flatted.python.test",
        "description": "node_modules.flatted.python.test",
        "peekOfCode": "o['test'] = {'test': 'OK'}\no['array'] = [1, 2, 3]\nassert stringify(a) == '[[\"0\",1,\"1\",true,\"2\",\"3\",\"4\"],\"two\",{\"o\":\"2\",\"one\":1,\"two\":\"1\",\"three\":true,\"a\":\"0\",\"test\":\"3\",\"array\":\"4\"},{\"test\":\"5\"},[1,2,3],\"OK\"]'\nassert stringify(o) == '[{\"o\":\"0\",\"one\":1,\"two\":\"1\",\"three\":true,\"a\":\"2\",\"test\":\"3\",\"array\":\"4\"},\"two\",[\"2\",1,\"1\",true,\"0\",\"3\",\"4\"],{\"test\":\"5\"},[1,2,3],\"OK\"]'\na2 = parse(stringify(a));\no2 = parse(stringify(o));\nassert a2[0] == a2\nassert o2['o'] == o2\nassert a2[1] == 1 and a2[2] == 'two' and a2[3] == True and isinstance(a2[4], dict)\nassert a2[4] == a2[4]['o'] and a2 == a2[4]['o']['a']",
        "detail": "node_modules.flatted.python.test",
        "documentation": {}
    },
    {
        "label": "o['array']",
        "kind": 5,
        "importPath": "node_modules.flatted.python.test",
        "description": "node_modules.flatted.python.test",
        "peekOfCode": "o['array'] = [1, 2, 3]\nassert stringify(a) == '[[\"0\",1,\"1\",true,\"2\",\"3\",\"4\"],\"two\",{\"o\":\"2\",\"one\":1,\"two\":\"1\",\"three\":true,\"a\":\"0\",\"test\":\"3\",\"array\":\"4\"},{\"test\":\"5\"},[1,2,3],\"OK\"]'\nassert stringify(o) == '[{\"o\":\"0\",\"one\":1,\"two\":\"1\",\"three\":true,\"a\":\"2\",\"test\":\"3\",\"array\":\"4\"},\"two\",[\"2\",1,\"1\",true,\"0\",\"3\",\"4\"],{\"test\":\"5\"},[1,2,3],\"OK\"]'\na2 = parse(stringify(a));\no2 = parse(stringify(o));\nassert a2[0] == a2\nassert o2['o'] == o2\nassert a2[1] == 1 and a2[2] == 'two' and a2[3] == True and isinstance(a2[4], dict)\nassert a2[4] == a2[4]['o'] and a2 == a2[4]['o']['a']\nstr = parse('[{\"prop\":\"1\",\"a\":\"2\",\"b\":\"3\"},{\"value\":123},[\"4\",\"5\"],{\"e\":\"6\",\"t\":\"7\",\"p\":4},{},{\"b\":\"8\"},\"f\",{\"a\":\"9\"},[\"10\"],\"sup\",{\"a\":1,\"d\":2,\"c\":\"7\",\"z\":\"11\",\"h\":1},{\"g\":2,\"a\":\"7\",\"b\":\"12\",\"f\":6},{\"r\":4,\"u\":\"7\",\"c\":5}]')",
        "detail": "node_modules.flatted.python.test",
        "documentation": {}
    },
    {
        "label": "a2",
        "kind": 5,
        "importPath": "node_modules.flatted.python.test",
        "description": "node_modules.flatted.python.test",
        "peekOfCode": "a2 = parse(stringify(a));\no2 = parse(stringify(o));\nassert a2[0] == a2\nassert o2['o'] == o2\nassert a2[1] == 1 and a2[2] == 'two' and a2[3] == True and isinstance(a2[4], dict)\nassert a2[4] == a2[4]['o'] and a2 == a2[4]['o']['a']\nstr = parse('[{\"prop\":\"1\",\"a\":\"2\",\"b\":\"3\"},{\"value\":123},[\"4\",\"5\"],{\"e\":\"6\",\"t\":\"7\",\"p\":4},{},{\"b\":\"8\"},\"f\",{\"a\":\"9\"},[\"10\"],\"sup\",{\"a\":1,\"d\":2,\"c\":\"7\",\"z\":\"11\",\"h\":1},{\"g\":2,\"a\":\"7\",\"b\":\"12\",\"f\":6},{\"r\":4,\"u\":\"7\",\"c\":5}]')\nassert str['b']['t']['a'] == 'sup' and str['a'][1]['b'][0]['c'] == str['b']['t']\noo = parse('[{\"a\":\"1\",\"b\":\"0\",\"c\":\"2\"},{\"aa\":\"3\"},{\"ca\":\"4\",\"cb\":\"5\",\"cc\":\"6\",\"cd\":\"7\",\"ce\":\"8\",\"cf\":\"9\"},{\"aaa\":\"10\"},{\"caa\":\"4\"},{\"cba\":\"5\"},{\"cca\":\"2\"},{\"cda\":\"4\"},\"value2\",\"value3\",\"value1\"]');\nassert oo['a']['aa']['aaa'] == 'value1' and oo == oo['b'] and oo['c']['ca']['caa'] == oo['c']['ca']",
        "detail": "node_modules.flatted.python.test",
        "documentation": {}
    },
    {
        "label": "o2",
        "kind": 5,
        "importPath": "node_modules.flatted.python.test",
        "description": "node_modules.flatted.python.test",
        "peekOfCode": "o2 = parse(stringify(o));\nassert a2[0] == a2\nassert o2['o'] == o2\nassert a2[1] == 1 and a2[2] == 'two' and a2[3] == True and isinstance(a2[4], dict)\nassert a2[4] == a2[4]['o'] and a2 == a2[4]['o']['a']\nstr = parse('[{\"prop\":\"1\",\"a\":\"2\",\"b\":\"3\"},{\"value\":123},[\"4\",\"5\"],{\"e\":\"6\",\"t\":\"7\",\"p\":4},{},{\"b\":\"8\"},\"f\",{\"a\":\"9\"},[\"10\"],\"sup\",{\"a\":1,\"d\":2,\"c\":\"7\",\"z\":\"11\",\"h\":1},{\"g\":2,\"a\":\"7\",\"b\":\"12\",\"f\":6},{\"r\":4,\"u\":\"7\",\"c\":5}]')\nassert str['b']['t']['a'] == 'sup' and str['a'][1]['b'][0]['c'] == str['b']['t']\noo = parse('[{\"a\":\"1\",\"b\":\"0\",\"c\":\"2\"},{\"aa\":\"3\"},{\"ca\":\"4\",\"cb\":\"5\",\"cc\":\"6\",\"cd\":\"7\",\"ce\":\"8\",\"cf\":\"9\"},{\"aaa\":\"10\"},{\"caa\":\"4\"},{\"cba\":\"5\"},{\"cca\":\"2\"},{\"cda\":\"4\"},\"value2\",\"value3\",\"value1\"]');\nassert oo['a']['aa']['aaa'] == 'value1' and oo == oo['b'] and oo['c']['ca']['caa'] == oo['c']['ca']\nprint('OK')",
        "detail": "node_modules.flatted.python.test",
        "documentation": {}
    },
    {
        "label": "str",
        "kind": 5,
        "importPath": "node_modules.flatted.python.test",
        "description": "node_modules.flatted.python.test",
        "peekOfCode": "str = parse('[{\"prop\":\"1\",\"a\":\"2\",\"b\":\"3\"},{\"value\":123},[\"4\",\"5\"],{\"e\":\"6\",\"t\":\"7\",\"p\":4},{},{\"b\":\"8\"},\"f\",{\"a\":\"9\"},[\"10\"],\"sup\",{\"a\":1,\"d\":2,\"c\":\"7\",\"z\":\"11\",\"h\":1},{\"g\":2,\"a\":\"7\",\"b\":\"12\",\"f\":6},{\"r\":4,\"u\":\"7\",\"c\":5}]')\nassert str['b']['t']['a'] == 'sup' and str['a'][1]['b'][0]['c'] == str['b']['t']\noo = parse('[{\"a\":\"1\",\"b\":\"0\",\"c\":\"2\"},{\"aa\":\"3\"},{\"ca\":\"4\",\"cb\":\"5\",\"cc\":\"6\",\"cd\":\"7\",\"ce\":\"8\",\"cf\":\"9\"},{\"aaa\":\"10\"},{\"caa\":\"4\"},{\"cba\":\"5\"},{\"cca\":\"2\"},{\"cda\":\"4\"},\"value2\",\"value3\",\"value1\"]');\nassert oo['a']['aa']['aaa'] == 'value1' and oo == oo['b'] and oo['c']['ca']['caa'] == oo['c']['ca']\nprint('OK')",
        "detail": "node_modules.flatted.python.test",
        "documentation": {}
    },
    {
        "label": "oo",
        "kind": 5,
        "importPath": "node_modules.flatted.python.test",
        "description": "node_modules.flatted.python.test",
        "peekOfCode": "oo = parse('[{\"a\":\"1\",\"b\":\"0\",\"c\":\"2\"},{\"aa\":\"3\"},{\"ca\":\"4\",\"cb\":\"5\",\"cc\":\"6\",\"cd\":\"7\",\"ce\":\"8\",\"cf\":\"9\"},{\"aaa\":\"10\"},{\"caa\":\"4\"},{\"cba\":\"5\"},{\"cca\":\"2\"},{\"cda\":\"4\"},\"value2\",\"value3\",\"value1\"]');\nassert oo['a']['aa']['aaa'] == 'value1' and oo == oo['b'] and oo['c']['ca']['caa'] == oo['c']['ca']\nprint('OK')",
        "detail": "node_modules.flatted.python.test",
        "documentation": {}
    },
    {
        "label": "QUERY_PATH",
        "kind": 5,
        "importPath": "src.app.api.audio-retrieval.audioConvert",
        "description": "src.app.api.audio-retrieval.audioConvert",
        "peekOfCode": "QUERY_PATH = \"./public/query/audio/\"\n# Input and output paths\naudio_path = \"input.mp3\"\noutput_path = \"output.mid\"\n# Convert audio to MIDI\npredict_and_save(\n    audio_path_list=[QUERY_PATH+audio_path],\n    output_directory=QUERY_PATH,\n    save_midi=True,\n    sonify_midi=False,",
        "detail": "src.app.api.audio-retrieval.audioConvert",
        "documentation": {}
    },
    {
        "label": "audio_path",
        "kind": 5,
        "importPath": "src.app.api.audio-retrieval.audioConvert",
        "description": "src.app.api.audio-retrieval.audioConvert",
        "peekOfCode": "audio_path = \"input.mp3\"\noutput_path = \"output.mid\"\n# Convert audio to MIDI\npredict_and_save(\n    audio_path_list=[QUERY_PATH+audio_path],\n    output_directory=QUERY_PATH,\n    save_midi=True,\n    sonify_midi=False,\n    save_model_outputs=False,\n    save_notes=False,",
        "detail": "src.app.api.audio-retrieval.audioConvert",
        "documentation": {}
    },
    {
        "label": "output_path",
        "kind": 5,
        "importPath": "src.app.api.audio-retrieval.audioConvert",
        "description": "src.app.api.audio-retrieval.audioConvert",
        "peekOfCode": "output_path = \"output.mid\"\n# Convert audio to MIDI\npredict_and_save(\n    audio_path_list=[QUERY_PATH+audio_path],\n    output_directory=QUERY_PATH,\n    save_midi=True,\n    sonify_midi=False,\n    save_model_outputs=False,\n    save_notes=False,\n    model_or_model_path=ICASSP_2022_MODEL_PATH",
        "detail": "src.app.api.audio-retrieval.audioConvert",
        "documentation": {}
    },
    {
        "label": "process_database",
        "kind": 2,
        "importPath": "src.app.api.audio-retrieval.audioDatabase",
        "description": "src.app.api.audio-retrieval.audioDatabase",
        "peekOfCode": "def process_database(database_path: str, temp_path: str = TEMP_PATH) -> list[tuple[str, Features]]:\n    if not os.path.exists(database_path):\n        return\n    database = []\n    files = [f for f in os.listdir(database_path) if os.path.isfile(os.path.join(database_path, f))]\n    if not os.path.exists(temp_path):\n        os.makedirs(temp_path)\n    nonmidi_files = []\n    for file_name in files:\n        source_file = os.path.join(database_path, file_name)",
        "detail": "src.app.api.audio-retrieval.audioDatabase",
        "documentation": {}
    },
    {
        "label": "sys.stdout",
        "kind": 5,
        "importPath": "src.app.api.audio-retrieval.audioDatabase",
        "description": "src.app.api.audio-retrieval.audioDatabase",
        "peekOfCode": "sys.stdout = codecs.getwriter(\"utf-8\")(sys.stdout.buffer, 'strict')\nos.environ['PYTHONIOENCODING'] = 'utf-8'\nDATABASE_PATH = os.path.join(os.getcwd(), \"public\", \"uploads\", \"audio\") + \"/\"\nTEMP_PATH = os.path.join(os.getcwd(), \"public\", \"uploads\", \"audio-temp\") + \"/\"\nPKL_PATH = os.path.join(os.getcwd(), \"database\", \"audioDataset.pkl\")\ndef process_database(database_path: str, temp_path: str = TEMP_PATH) -> list[tuple[str, Features]]:\n    if not os.path.exists(database_path):\n        return\n    database = []\n    files = [f for f in os.listdir(database_path) if os.path.isfile(os.path.join(database_path, f))]",
        "detail": "src.app.api.audio-retrieval.audioDatabase",
        "documentation": {}
    },
    {
        "label": "os.environ['PYTHONIOENCODING']",
        "kind": 5,
        "importPath": "src.app.api.audio-retrieval.audioDatabase",
        "description": "src.app.api.audio-retrieval.audioDatabase",
        "peekOfCode": "os.environ['PYTHONIOENCODING'] = 'utf-8'\nDATABASE_PATH = os.path.join(os.getcwd(), \"public\", \"uploads\", \"audio\") + \"/\"\nTEMP_PATH = os.path.join(os.getcwd(), \"public\", \"uploads\", \"audio-temp\") + \"/\"\nPKL_PATH = os.path.join(os.getcwd(), \"database\", \"audioDataset.pkl\")\ndef process_database(database_path: str, temp_path: str = TEMP_PATH) -> list[tuple[str, Features]]:\n    if not os.path.exists(database_path):\n        return\n    database = []\n    files = [f for f in os.listdir(database_path) if os.path.isfile(os.path.join(database_path, f))]\n    if not os.path.exists(temp_path):",
        "detail": "src.app.api.audio-retrieval.audioDatabase",
        "documentation": {}
    },
    {
        "label": "DATABASE_PATH",
        "kind": 5,
        "importPath": "src.app.api.audio-retrieval.audioDatabase",
        "description": "src.app.api.audio-retrieval.audioDatabase",
        "peekOfCode": "DATABASE_PATH = os.path.join(os.getcwd(), \"public\", \"uploads\", \"audio\") + \"/\"\nTEMP_PATH = os.path.join(os.getcwd(), \"public\", \"uploads\", \"audio-temp\") + \"/\"\nPKL_PATH = os.path.join(os.getcwd(), \"database\", \"audioDataset.pkl\")\ndef process_database(database_path: str, temp_path: str = TEMP_PATH) -> list[tuple[str, Features]]:\n    if not os.path.exists(database_path):\n        return\n    database = []\n    files = [f for f in os.listdir(database_path) if os.path.isfile(os.path.join(database_path, f))]\n    if not os.path.exists(temp_path):\n        os.makedirs(temp_path)",
        "detail": "src.app.api.audio-retrieval.audioDatabase",
        "documentation": {}
    },
    {
        "label": "TEMP_PATH",
        "kind": 5,
        "importPath": "src.app.api.audio-retrieval.audioDatabase",
        "description": "src.app.api.audio-retrieval.audioDatabase",
        "peekOfCode": "TEMP_PATH = os.path.join(os.getcwd(), \"public\", \"uploads\", \"audio-temp\") + \"/\"\nPKL_PATH = os.path.join(os.getcwd(), \"database\", \"audioDataset.pkl\")\ndef process_database(database_path: str, temp_path: str = TEMP_PATH) -> list[tuple[str, Features]]:\n    if not os.path.exists(database_path):\n        return\n    database = []\n    files = [f for f in os.listdir(database_path) if os.path.isfile(os.path.join(database_path, f))]\n    if not os.path.exists(temp_path):\n        os.makedirs(temp_path)\n    nonmidi_files = []",
        "detail": "src.app.api.audio-retrieval.audioDatabase",
        "documentation": {}
    },
    {
        "label": "PKL_PATH",
        "kind": 5,
        "importPath": "src.app.api.audio-retrieval.audioDatabase",
        "description": "src.app.api.audio-retrieval.audioDatabase",
        "peekOfCode": "PKL_PATH = os.path.join(os.getcwd(), \"database\", \"audioDataset.pkl\")\ndef process_database(database_path: str, temp_path: str = TEMP_PATH) -> list[tuple[str, Features]]:\n    if not os.path.exists(database_path):\n        return\n    database = []\n    files = [f for f in os.listdir(database_path) if os.path.isfile(os.path.join(database_path, f))]\n    if not os.path.exists(temp_path):\n        os.makedirs(temp_path)\n    nonmidi_files = []\n    for file_name in files:",
        "detail": "src.app.api.audio-retrieval.audioDatabase",
        "documentation": {}
    },
    {
        "label": "PKL_PATH",
        "kind": 5,
        "importPath": "src.app.api.audio-retrieval.audioPKL",
        "description": "src.app.api.audio-retrieval.audioPKL",
        "peekOfCode": "PKL_PATH = os.path.join(os.getcwd(), \"database\", \"audioDataset.pkl\")\nif __name__ == \"__main__\":\n    with open(PKL_PATH, \"rb\") as file:\n        database: list[tuple[str, Features]] = pickle.load(file)\n    for music in database:\n        print(music[0])",
        "detail": "src.app.api.audio-retrieval.audioPKL",
        "documentation": {}
    },
    {
        "label": "display_midi_info",
        "kind": 2,
        "importPath": "src.app.api.audio-retrieval.audioRead",
        "description": "src.app.api.audio-retrieval.audioRead",
        "peekOfCode": "def display_midi_info(file_path):\n    try:\n        # Open the MIDI file\n        midi = mido.MidiFile(file_path)\n        # Display general file information\n        print(\"--- General MIDI File Info ---\")\n        print(f\"File Type: {midi.type}\")\n        print(f\"Number of Tracks: {len(midi.tracks)}\")\n        print(f\"Ticks per Beat: {midi.ticks_per_beat}\")\n        print()",
        "detail": "src.app.api.audio-retrieval.audioRead",
        "documentation": {}
    },
    {
        "label": "file_path",
        "kind": 5,
        "importPath": "src.app.api.audio-retrieval.audioRead",
        "description": "src.app.api.audio-retrieval.audioRead",
        "peekOfCode": "file_path = input(\"Enter the path to the MIDI file: \")\ndisplay_midi_info(file_path)",
        "detail": "src.app.api.audio-retrieval.audioRead",
        "documentation": {}
    },
    {
        "label": "Features",
        "kind": 6,
        "importPath": "src.app.api.audio-retrieval.audioSearching",
        "description": "src.app.api.audio-retrieval.audioSearching",
        "peekOfCode": "class Features:\n    ATB: list[int]\n    RTB: list[int]\n    FTB: list[int]\n    ATB_norm: float\n    RTB_norm: float\n    FTB_norm: float\ndef extract_features(current_segment: list[int]) -> Features:\n        features = Features([], [], [], 0, 0, 0)\n        # extract ATB feature",
        "detail": "src.app.api.audio-retrieval.audioSearching",
        "documentation": {}
    },
    {
        "label": "extract_features",
        "kind": 2,
        "importPath": "src.app.api.audio-retrieval.audioSearching",
        "description": "src.app.api.audio-retrieval.audioSearching",
        "peekOfCode": "def extract_features(current_segment: list[int]) -> Features:\n        features = Features([], [], [], 0, 0, 0)\n        # extract ATB feature\n        bins_128 = np.arange(0, 128 + 1)\n        ATB = np.histogram(current_segment, bins=bins_128)[0]\n        features.ATB = ATB / ATB.sum()\n        # extract RTB feature\n        bins_255 = np.arange(-127, 128 + 1)\n        RTB_current_segment = []\n        for i in range(len(current_segment) - 1):",
        "detail": "src.app.api.audio-retrieval.audioSearching",
        "documentation": {}
    },
    {
        "label": "process_audio",
        "kind": 2,
        "importPath": "src.app.api.audio-retrieval.audioSearching",
        "description": "src.app.api.audio-retrieval.audioSearching",
        "peekOfCode": "def process_audio(path: str) -> list[Features]:\n    midi_file = mido.MidiFile(path)\n    ticks_per_beat = midi_file.ticks_per_beat\n    current_segment_length = SEGMENT * ticks_per_beat\n    slide_length = SLIDE * ticks_per_beat\n    music_features = []\n    for track_index, track in enumerate(midi_file.tracks):\n        track_ticks = 0\n        cumulative_ticks = []\n        for msg in track:",
        "detail": "src.app.api.audio-retrieval.audioSearching",
        "documentation": {}
    },
    {
        "label": "minmax_normalize",
        "kind": 2,
        "importPath": "src.app.api.audio-retrieval.audioSearching",
        "description": "src.app.api.audio-retrieval.audioSearching",
        "peekOfCode": "def minmax_normalize(array: list[int]) -> list:\n    return (array - np.min(array)) / (np.max(array) - np.min(array))\ndef standard_normalize(array: list[int]) -> list:\n    return (array - np.mean(array)) / np.std(array)\ndef cosine_similarity(v1: list[int], v2: list[int], norm1: int, norm2: int) -> float:\n    return np.dot(v1, v2) / (norm1 * norm2)\ndef compare_features(features1: Features, features2: Features, atb_weight: int = ATB_WEIGHT, rtb_weight: int = RTB_WEIGHT, ftb_weight: int = FTB_WEIGHT) -> float:\n    return cosine_similarity(features1.ATB, features2.ATB, features1.ATB_norm, features2.ATB_norm) * atb_weight + cosine_similarity(features1.RTB, features2.RTB, features1.RTB_norm, features2.RTB_norm) * rtb_weight + cosine_similarity(features1.FTB, features2.FTB, features1.FTB_norm, features2.FTB_norm) * ftb_weight\ndef compare_music(music1: list[Features], music2: list[Features]) -> float:\n    max = 0",
        "detail": "src.app.api.audio-retrieval.audioSearching",
        "documentation": {}
    },
    {
        "label": "standard_normalize",
        "kind": 2,
        "importPath": "src.app.api.audio-retrieval.audioSearching",
        "description": "src.app.api.audio-retrieval.audioSearching",
        "peekOfCode": "def standard_normalize(array: list[int]) -> list:\n    return (array - np.mean(array)) / np.std(array)\ndef cosine_similarity(v1: list[int], v2: list[int], norm1: int, norm2: int) -> float:\n    return np.dot(v1, v2) / (norm1 * norm2)\ndef compare_features(features1: Features, features2: Features, atb_weight: int = ATB_WEIGHT, rtb_weight: int = RTB_WEIGHT, ftb_weight: int = FTB_WEIGHT) -> float:\n    return cosine_similarity(features1.ATB, features2.ATB, features1.ATB_norm, features2.ATB_norm) * atb_weight + cosine_similarity(features1.RTB, features2.RTB, features1.RTB_norm, features2.RTB_norm) * rtb_weight + cosine_similarity(features1.FTB, features2.FTB, features1.FTB_norm, features2.FTB_norm) * ftb_weight\ndef compare_music(music1: list[Features], music2: list[Features]) -> float:\n    max = 0\n    for feature1 in music1:\n        for feature2 in music2:",
        "detail": "src.app.api.audio-retrieval.audioSearching",
        "documentation": {}
    },
    {
        "label": "cosine_similarity",
        "kind": 2,
        "importPath": "src.app.api.audio-retrieval.audioSearching",
        "description": "src.app.api.audio-retrieval.audioSearching",
        "peekOfCode": "def cosine_similarity(v1: list[int], v2: list[int], norm1: int, norm2: int) -> float:\n    return np.dot(v1, v2) / (norm1 * norm2)\ndef compare_features(features1: Features, features2: Features, atb_weight: int = ATB_WEIGHT, rtb_weight: int = RTB_WEIGHT, ftb_weight: int = FTB_WEIGHT) -> float:\n    return cosine_similarity(features1.ATB, features2.ATB, features1.ATB_norm, features2.ATB_norm) * atb_weight + cosine_similarity(features1.RTB, features2.RTB, features1.RTB_norm, features2.RTB_norm) * rtb_weight + cosine_similarity(features1.FTB, features2.FTB, features1.FTB_norm, features2.FTB_norm) * ftb_weight\ndef compare_music(music1: list[Features], music2: list[Features]) -> float:\n    max = 0\n    for feature1 in music1:\n        for feature2 in music2:\n            score = compare_features(feature1, feature2)\n            if score > max:",
        "detail": "src.app.api.audio-retrieval.audioSearching",
        "documentation": {}
    },
    {
        "label": "compare_features",
        "kind": 2,
        "importPath": "src.app.api.audio-retrieval.audioSearching",
        "description": "src.app.api.audio-retrieval.audioSearching",
        "peekOfCode": "def compare_features(features1: Features, features2: Features, atb_weight: int = ATB_WEIGHT, rtb_weight: int = RTB_WEIGHT, ftb_weight: int = FTB_WEIGHT) -> float:\n    return cosine_similarity(features1.ATB, features2.ATB, features1.ATB_norm, features2.ATB_norm) * atb_weight + cosine_similarity(features1.RTB, features2.RTB, features1.RTB_norm, features2.RTB_norm) * rtb_weight + cosine_similarity(features1.FTB, features2.FTB, features1.FTB_norm, features2.FTB_norm) * ftb_weight\ndef compare_music(music1: list[Features], music2: list[Features]) -> float:\n    max = 0\n    for feature1 in music1:\n        for feature2 in music2:\n            score = compare_features(feature1, feature2)\n            if score > max:\n                max = float(score)\n    return max",
        "detail": "src.app.api.audio-retrieval.audioSearching",
        "documentation": {}
    },
    {
        "label": "compare_music",
        "kind": 2,
        "importPath": "src.app.api.audio-retrieval.audioSearching",
        "description": "src.app.api.audio-retrieval.audioSearching",
        "peekOfCode": "def compare_music(music1: list[Features], music2: list[Features]) -> float:\n    max = 0\n    for feature1 in music1:\n        for feature2 in music2:\n            score = compare_features(feature1, feature2)\n            if score > max:\n                max = float(score)\n    return max\ndef find_best_match(music: list[Features], db: list[tuple[list[Features], list[str]]]) -> list[tuple[str, float]]:\n    best_scores = []",
        "detail": "src.app.api.audio-retrieval.audioSearching",
        "documentation": {}
    },
    {
        "label": "find_best_match",
        "kind": 2,
        "importPath": "src.app.api.audio-retrieval.audioSearching",
        "description": "src.app.api.audio-retrieval.audioSearching",
        "peekOfCode": "def find_best_match(music: list[Features], db: list[tuple[list[Features], list[str]]]) -> list[tuple[str, float]]:\n    best_scores = []\n    for file_name, features in db:\n        score = compare_music(music, features)\n        best_scores.append((file_name, score))\n    best_scores.sort(key=lambda x: x[1], reverse=True)\n    return best_scores\ndef search_music(music_path: str, max_result: int) -> list[tuple[str, float]]:\n    if os.path.splitext(music_path)[1] != \".mid\":\n        music_path = os.path.splitext(music_path)[0] + \"_basic_pitch.mid\"",
        "detail": "src.app.api.audio-retrieval.audioSearching",
        "documentation": {}
    },
    {
        "label": "search_music",
        "kind": 2,
        "importPath": "src.app.api.audio-retrieval.audioSearching",
        "description": "src.app.api.audio-retrieval.audioSearching",
        "peekOfCode": "def search_music(music_path: str, max_result: int) -> list[tuple[str, float]]:\n    if os.path.splitext(music_path)[1] != \".mid\":\n        music_path = os.path.splitext(music_path)[0] + \"_basic_pitch.mid\"\n    music = process_audio(music_path)\n    return find_best_match(music, database)[:max_result]\ndef print_results(results: list[tuple[str, float]]):\n    json_results = [\n        {\n            'filename': result[0],\n            'score': result[1] * 100",
        "detail": "src.app.api.audio-retrieval.audioSearching",
        "documentation": {}
    },
    {
        "label": "print_results",
        "kind": 2,
        "importPath": "src.app.api.audio-retrieval.audioSearching",
        "description": "src.app.api.audio-retrieval.audioSearching",
        "peekOfCode": "def print_results(results: list[tuple[str, float]]):\n    json_results = [\n        {\n            'filename': result[0],\n            'score': result[1] * 100\n        }\n        for result in results\n    ]\n    print(json.dumps(json_results))\nif __name__ == \"__main__\":",
        "detail": "src.app.api.audio-retrieval.audioSearching",
        "documentation": {}
    },
    {
        "label": "DATABASE_PATH",
        "kind": 5,
        "importPath": "src.app.api.audio-retrieval.audioSearching",
        "description": "src.app.api.audio-retrieval.audioSearching",
        "peekOfCode": "DATABASE_PATH = os.path.join(os.getcwd(), \"public\", \"uploads\", \"audio\")\nQUERY_PATH = os.path.join(os.getcwd(), \"public\", \"query\", \"audio\")\nPKL_PATH = os.path.join(os.getcwd(), \"database\", \"audioDataset.pkl\")\nSEGMENT = 20\nSLIDE = 2\nATB_WEIGHT = 0.33\nRTB_WEIGHT = 0.33\nFTB_WEIGHT = 0.33\ndatabase = []\n@dataclass",
        "detail": "src.app.api.audio-retrieval.audioSearching",
        "documentation": {}
    },
    {
        "label": "QUERY_PATH",
        "kind": 5,
        "importPath": "src.app.api.audio-retrieval.audioSearching",
        "description": "src.app.api.audio-retrieval.audioSearching",
        "peekOfCode": "QUERY_PATH = os.path.join(os.getcwd(), \"public\", \"query\", \"audio\")\nPKL_PATH = os.path.join(os.getcwd(), \"database\", \"audioDataset.pkl\")\nSEGMENT = 20\nSLIDE = 2\nATB_WEIGHT = 0.33\nRTB_WEIGHT = 0.33\nFTB_WEIGHT = 0.33\ndatabase = []\n@dataclass\nclass Features:",
        "detail": "src.app.api.audio-retrieval.audioSearching",
        "documentation": {}
    },
    {
        "label": "PKL_PATH",
        "kind": 5,
        "importPath": "src.app.api.audio-retrieval.audioSearching",
        "description": "src.app.api.audio-retrieval.audioSearching",
        "peekOfCode": "PKL_PATH = os.path.join(os.getcwd(), \"database\", \"audioDataset.pkl\")\nSEGMENT = 20\nSLIDE = 2\nATB_WEIGHT = 0.33\nRTB_WEIGHT = 0.33\nFTB_WEIGHT = 0.33\ndatabase = []\n@dataclass\nclass Features:\n    ATB: list[int]",
        "detail": "src.app.api.audio-retrieval.audioSearching",
        "documentation": {}
    },
    {
        "label": "SEGMENT",
        "kind": 5,
        "importPath": "src.app.api.audio-retrieval.audioSearching",
        "description": "src.app.api.audio-retrieval.audioSearching",
        "peekOfCode": "SEGMENT = 20\nSLIDE = 2\nATB_WEIGHT = 0.33\nRTB_WEIGHT = 0.33\nFTB_WEIGHT = 0.33\ndatabase = []\n@dataclass\nclass Features:\n    ATB: list[int]\n    RTB: list[int]",
        "detail": "src.app.api.audio-retrieval.audioSearching",
        "documentation": {}
    },
    {
        "label": "SLIDE",
        "kind": 5,
        "importPath": "src.app.api.audio-retrieval.audioSearching",
        "description": "src.app.api.audio-retrieval.audioSearching",
        "peekOfCode": "SLIDE = 2\nATB_WEIGHT = 0.33\nRTB_WEIGHT = 0.33\nFTB_WEIGHT = 0.33\ndatabase = []\n@dataclass\nclass Features:\n    ATB: list[int]\n    RTB: list[int]\n    FTB: list[int]",
        "detail": "src.app.api.audio-retrieval.audioSearching",
        "documentation": {}
    },
    {
        "label": "ATB_WEIGHT",
        "kind": 5,
        "importPath": "src.app.api.audio-retrieval.audioSearching",
        "description": "src.app.api.audio-retrieval.audioSearching",
        "peekOfCode": "ATB_WEIGHT = 0.33\nRTB_WEIGHT = 0.33\nFTB_WEIGHT = 0.33\ndatabase = []\n@dataclass\nclass Features:\n    ATB: list[int]\n    RTB: list[int]\n    FTB: list[int]\n    ATB_norm: float",
        "detail": "src.app.api.audio-retrieval.audioSearching",
        "documentation": {}
    },
    {
        "label": "RTB_WEIGHT",
        "kind": 5,
        "importPath": "src.app.api.audio-retrieval.audioSearching",
        "description": "src.app.api.audio-retrieval.audioSearching",
        "peekOfCode": "RTB_WEIGHT = 0.33\nFTB_WEIGHT = 0.33\ndatabase = []\n@dataclass\nclass Features:\n    ATB: list[int]\n    RTB: list[int]\n    FTB: list[int]\n    ATB_norm: float\n    RTB_norm: float",
        "detail": "src.app.api.audio-retrieval.audioSearching",
        "documentation": {}
    },
    {
        "label": "FTB_WEIGHT",
        "kind": 5,
        "importPath": "src.app.api.audio-retrieval.audioSearching",
        "description": "src.app.api.audio-retrieval.audioSearching",
        "peekOfCode": "FTB_WEIGHT = 0.33\ndatabase = []\n@dataclass\nclass Features:\n    ATB: list[int]\n    RTB: list[int]\n    FTB: list[int]\n    ATB_norm: float\n    RTB_norm: float\n    FTB_norm: float",
        "detail": "src.app.api.audio-retrieval.audioSearching",
        "documentation": {}
    },
    {
        "label": "database",
        "kind": 5,
        "importPath": "src.app.api.audio-retrieval.audioSearching",
        "description": "src.app.api.audio-retrieval.audioSearching",
        "peekOfCode": "database = []\n@dataclass\nclass Features:\n    ATB: list[int]\n    RTB: list[int]\n    FTB: list[int]\n    ATB_norm: float\n    RTB_norm: float\n    FTB_norm: float\ndef extract_features(current_segment: list[int]) -> Features:",
        "detail": "src.app.api.audio-retrieval.audioSearching",
        "documentation": {}
    },
    {
        "label": "grayscaleConvert",
        "kind": 2,
        "importPath": "src.app.api.image-retrieval.imageSearching",
        "description": "src.app.api.image-retrieval.imageSearching",
        "peekOfCode": "def grayscaleConvert(image):\n    imgArray = np.asarray(image, dtype=np.float32)\n    redArr = imgArray[:,:,0]\n    greenArr = imgArray[:,:,1]\n    blueArr = imgArray[:,:,2]\n    grayscale = 0.2989*redArr + 0.5870*greenArr + 0.1140*blueArr\n    return grayscale\ndef flattenImage(grayscale_image):\n    M, N = grayscale_image.shape                            # M = baris, N = kolom\n    flattened_vector = []",
        "detail": "src.app.api.image-retrieval.imageSearching",
        "documentation": {}
    },
    {
        "label": "flattenImage",
        "kind": 2,
        "importPath": "src.app.api.image-retrieval.imageSearching",
        "description": "src.app.api.image-retrieval.imageSearching",
        "peekOfCode": "def flattenImage(grayscale_image):\n    M, N = grayscale_image.shape                            # M = baris, N = kolom\n    flattened_vector = []\n    for i in range(M):\n        for j in range(N):\n            flattened_vector.append(grayscale_image[i][j])\n    return np.array(flattened_vector)\ndef standardization(flattenImageSet):\n    sigmaPixel = np.sum(flattenImageSet, axis=0)                # array [jumlah pixel ke-j dari tiap image i]\n    N = flattenImageSet.shape[0]",
        "detail": "src.app.api.image-retrieval.imageSearching",
        "documentation": {}
    },
    {
        "label": "standardization",
        "kind": 2,
        "importPath": "src.app.api.image-retrieval.imageSearching",
        "description": "src.app.api.image-retrieval.imageSearching",
        "peekOfCode": "def standardization(flattenImageSet):\n    sigmaPixel = np.sum(flattenImageSet, axis=0)                # array [jumlah pixel ke-j dari tiap image i]\n    N = flattenImageSet.shape[0]\n    M = flattenImageSet.shape[1]\n    # print(\"N\" + str(N))\n    # print(\"M\" + str(M))\n    mean = sigmaPixel/N\n    standardized = flattenImageSet - mean\n    return standardized, mean\ndef pcaSVD(standarSet, k = 100):",
        "detail": "src.app.api.image-retrieval.imageSearching",
        "documentation": {}
    },
    {
        "label": "pcaSVD",
        "kind": 2,
        "importPath": "src.app.api.image-retrieval.imageSearching",
        "description": "src.app.api.image-retrieval.imageSearching",
        "peekOfCode": "def pcaSVD(standarSet, k = 100):\n    C = (1 / standarSet.shape[0]) * standarSet.T @ standarSet  # C = (1/N) X^T X\n    U, Ev, Ut = np.linalg.svd(C, full_matrices=False)          # U@Ev@Ut = C\n    Uk = U[:,:k]\n    Z = standarSet @ Uk\n    return Z, Uk\ndef similarity(ZqImage, datasetVector, maxResult=60):\n    distances = np.linalg.norm(datasetVector - ZqImage, axis=1)  # axis=1 untuk menghitung jarak per baris\n    sortedIdxImage = np.argsort(distances)\n    sortedDistance = distances[sortedIdxImage]",
        "detail": "src.app.api.image-retrieval.imageSearching",
        "documentation": {}
    },
    {
        "label": "similarity",
        "kind": 2,
        "importPath": "src.app.api.image-retrieval.imageSearching",
        "description": "src.app.api.image-retrieval.imageSearching",
        "peekOfCode": "def similarity(ZqImage, datasetVector, maxResult=60):\n    distances = np.linalg.norm(datasetVector - ZqImage, axis=1)  # axis=1 untuk menghitung jarak per baris\n    sortedIdxImage = np.argsort(distances)\n    sortedDistance = distances[sortedIdxImage]\n    sortedIdxImage = sortedIdxImage[:maxResult]\n    sortedDistance = sortedDistance[:maxResult]\n    idxImg_Distance = [(idx, dist) for idx, dist in zip(sortedIdxImage, sortedDistance)]\n    return idxImg_Distance\ndef processImageFolder(folderPath: str, imgSize=(64,64)):\n    flattenedImageDataset = []",
        "detail": "src.app.api.image-retrieval.imageSearching",
        "documentation": {}
    },
    {
        "label": "processImageFolder",
        "kind": 2,
        "importPath": "src.app.api.image-retrieval.imageSearching",
        "description": "src.app.api.image-retrieval.imageSearching",
        "peekOfCode": "def processImageFolder(folderPath: str, imgSize=(64,64)):\n    flattenedImageDataset = []\n    imagesNameSet = []\n    for filename in os.listdir(folderPath):\n        if filename.endswith(('.png', '.jpg', '.jpeg')):\n            imgPath = os.path.join(folderPath, filename)\n            image = Image.open(imgPath).resize(imgSize)\n            grayscale = grayscaleConvert(image)\n            flattened = flattenImage(grayscale)\n            imagesNameSet.append(filename)",
        "detail": "src.app.api.image-retrieval.imageSearching",
        "documentation": {}
    },
    {
        "label": "searchImage",
        "kind": 2,
        "importPath": "src.app.api.image-retrieval.imageSearching",
        "description": "src.app.api.image-retrieval.imageSearching",
        "peekOfCode": "def searchImage(imagePath: str, folderPath: str, imgSize=(64, 64), k=100, maxResult=5):\n    qImage = Image.open(imagePath).resize(imgSize)\n    qGray = grayscaleConvert(qImage)\n    qFlattened = flattenImage(qGray)\n    # Proses Dataset\n    dataset, imagesNameSet = processImageFolder(folderPath, imgSize)\n    standardizedDataset, mean = standardization(dataset)\n    standardizedQ = qFlattened - mean\n    # PCA untuk proyeksi dataset dan query\n    Z, Uk = pcaSVD(standardizedDataset, k)",
        "detail": "src.app.api.image-retrieval.imageSearching",
        "documentation": {}
    },
    {
        "label": "standardization",
        "kind": 2,
        "importPath": "src.app.api.image-retrieval.LoadAndSearch",
        "description": "src.app.api.image-retrieval.LoadAndSearch",
        "peekOfCode": "def standardization(flattenImageSet):\n    sigmaPixel = np.sum(flattenImageSet, axis=0) # array [jumlah pixel ke-j dari tiap image i]\n    N = flattenImageSet.shape[0]\n    M = flattenImageSet.shape[1]\n    # print(\"N\" + str(N))\n    # print(\"M\" + str(M))\n    mean = sigmaPixel/N\n    standardized = flattenImageSet - mean\n    return standardized, mean\ndef pcaSVD(standarSet, k = 100):",
        "detail": "src.app.api.image-retrieval.LoadAndSearch",
        "documentation": {}
    },
    {
        "label": "pcaSVD",
        "kind": 2,
        "importPath": "src.app.api.image-retrieval.LoadAndSearch",
        "description": "src.app.api.image-retrieval.LoadAndSearch",
        "peekOfCode": "def pcaSVD(standarSet, k = 100):\n    C = (1 / standarSet.shape[0]) * standarSet.T @ standarSet #(1/N) X^T X\n    U, Ev, Ut = np.linalg.svd(C, full_matrices=False)\n    Uk = U[:,:k]\n    # print(str(standarSet.shape[0]), str(standarSet.shape[1]))\n    # print(str(U.shape[0]), str(U.shape[1]))\n    # print(str(Ut.shape[0]), str(Ut.shape[1]))\n    # print(str(Utk.shape[0]), str(Utk.shape[1]))\n    # print(str(C.shape[0]), str(C.shape[1]))\n    Z = standarSet @ Uk #k = 100",
        "detail": "src.app.api.image-retrieval.LoadAndSearch",
        "documentation": {}
    },
    {
        "label": "similarity",
        "kind": 2,
        "importPath": "src.app.api.image-retrieval.LoadAndSearch",
        "description": "src.app.api.image-retrieval.LoadAndSearch",
        "peekOfCode": "def similarity(query_vector, dataset_vectors, max_results=60):\n    distances = np.linalg.norm(dataset_vectors - query_vector, axis=1)  # axis=1 untuk menghitung jarak per baris\n    sorted_indices = np.argsort(distances)  # Urutkan indeks berdasarkan jarak\n    sorted_distances = distances[sorted_indices]  # Jarak yang sudah diurutkan\n    closest_indices = sorted_indices[:max_results]\n    closest_distances = sorted_distances[:max_results]\n    # Gabungkan index dan distance menjadi list of tuples\n    list_tuples = [(idx, dist) for idx, dist in zip(sorted_indices, sorted_distances)]\n    return list_tuples\ndef searchImage(imagePath: str, folderPath: str, imgSize=(50, 50), k=100, maxResult=5):",
        "detail": "src.app.api.image-retrieval.LoadAndSearch",
        "documentation": {}
    },
    {
        "label": "searchImage",
        "kind": 2,
        "importPath": "src.app.api.image-retrieval.LoadAndSearch",
        "description": "src.app.api.image-retrieval.LoadAndSearch",
        "peekOfCode": "def searchImage(imagePath: str, folderPath: str, imgSize=(50, 50), k=100, maxResult=5):\n    qImage = Image.open(imagePath).resize(imgSize)\n    qGray = grayscaleConvert(qImage)\n    qFlattened = flattenImage(qGray)\n    path_to_dataset = os.path.join(os.getcwd(), 'database', 'imgDataset.txt')\n    path_to_imgName = os.path.join(os.getcwd(), 'database', 'ImgName.txt')\n    #load data\n    dataset = np.loadtxt(path_to_dataset)\n    imagesNameSet = pd.read_csv(path_to_imgName, header=None).squeeze().values\n    standardizedDataset, mean = standardization(dataset)",
        "detail": "src.app.api.image-retrieval.LoadAndSearch",
        "documentation": {}
    },
    {
        "label": "grayscaleConvert",
        "kind": 2,
        "importPath": "src.app.api.image-retrieval.processNewImage",
        "description": "src.app.api.image-retrieval.processNewImage",
        "peekOfCode": "def grayscaleConvert(image):\n    imgArray = np.asarray(image, dtype=np.float32)\n    redArr = imgArray[:,:,0]\n    greenArr = imgArray[:,:,1]\n    blueArr = imgArray[:,:,2]\n    grayscale = 0.2989*redArr + 0.5870*greenArr + 0.1140*blueArr\n    #print(grayscale)\n    return grayscale\ndef flattenImage(grayscale_image):\n    M, N = grayscale_image.shape                # M = baris, N = kolom",
        "detail": "src.app.api.image-retrieval.processNewImage",
        "documentation": {}
    },
    {
        "label": "flattenImage",
        "kind": 2,
        "importPath": "src.app.api.image-retrieval.processNewImage",
        "description": "src.app.api.image-retrieval.processNewImage",
        "peekOfCode": "def flattenImage(grayscale_image):\n    M, N = grayscale_image.shape                # M = baris, N = kolom\n    flattened_vector = []\n    for i in range(M):\n        for j in range(N):\n            flattened_vector.append(grayscale_image[i][j])\n    return np.array(flattened_vector)\ndef processImageFolder(folderPath: str, imgSize=(50,50)):\n    flattenedImageDataset = []\n    imagesNameSet = []",
        "detail": "src.app.api.image-retrieval.processNewImage",
        "documentation": {}
    },
    {
        "label": "processImageFolder",
        "kind": 2,
        "importPath": "src.app.api.image-retrieval.processNewImage",
        "description": "src.app.api.image-retrieval.processNewImage",
        "peekOfCode": "def processImageFolder(folderPath: str, imgSize=(50,50)):\n    flattenedImageDataset = []\n    imagesNameSet = []\n    for filename in os.listdir(folderPath):\n        if filename.endswith(('.png', '.jpg', '.jpeg')):\n            imgPath = os.path.join(folderPath, filename)\n            image = Image.open(imgPath).resize(imgSize)\n            grayscale = grayscaleConvert(image)\n            flattened = flattenImage(grayscale)\n            imagesNameSet.append(filename)",
        "detail": "src.app.api.image-retrieval.processNewImage",
        "documentation": {}
    },
    {
        "label": "inputNewImage",
        "kind": 2,
        "importPath": "src.app.api.image-retrieval.processNewImage",
        "description": "src.app.api.image-retrieval.processNewImage",
        "peekOfCode": "def inputNewImage(folderPath:str, imgSize=(50,50)):\n    path_to_dataset = os.path.join(os.getcwd(), 'database', 'imgDataset.txt')\n    path_to_imgName = os.path.join(os.getcwd(), 'database', 'ImgName.txt')\n    dataset = np.loadtxt(path_to_dataset)\n    imagesNameSet = pd.read_csv(path_to_imgName, header=None).squeeze().values\n    for filename in os.listdir(folderPath):\n        if filename.endswith(('.png', '.jpg', '.jpeg')):\n            imgPath = os.path.join(folderPath, filename)\n            image = Image.open(imgPath).resize(imgSize)\n            grayscale = grayscaleConvert(image)",
        "detail": "src.app.api.image-retrieval.processNewImage",
        "documentation": {}
    }
]